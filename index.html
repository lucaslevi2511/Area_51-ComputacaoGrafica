<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400&display=swap" rel="stylesheet">
    <title>Area 51</title>

    <style>
        /* --- RESET B√ÅSICO --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            height: 100vh;
            overflow: hidden; /* Evita barras de rolagem indesejadas */
            color: #fff;
            
            /* BACKGROUND: Substitua a URL abaixo pela sua imagem gerada */
            background: linear-gradient(rgba(0, 20, 0, 0.7), rgba(0, 0, 20, 0.8)), 
                        url('https://images.unsplash.com/photo-1518066000714-58c45f1a2c0a?q=80&w=2070&auto=format&fit=crop'); 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* --- LAYOUT PRINCIPAL --- */
        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 20px;
        }

        /* --- CABE√áALHO --- */
        header {
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00; /* Brilho Neon Verde */
            animation: glitch 3s infinite alternate;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            color: #ccff00; /* Verde-Amarelo Brasil Neon */
            letter-spacing: 5px;
            text-transform: uppercase;
        }

        /* --- √ÅREA DO CONTE√öDO (Canvas + Sidebar) --- */
        .content-wrapper {
            display: flex;
            flex: 1; /* Ocupa o resto da altura */
            gap: 30px;
            align-items: center; /* Centraliza verticalmente */
            justify-content: center; /* Centraliza horizontalmente */
            position: relative;
        }

        /* --- CANVAS WRAPPER --- */
        .canvas-container {
            position: relative;
            border: 2px solid rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            border-radius: 10px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.8);
            
            /* Garante que o canvas n√£o estoure a tela */
            max-width: 80vw;
            max-height: 70vh;
            display: flex;
        }

        canvas {
            display: block; /* Remove espa√ßo extra embaixo do canvas */
        }

        /* --- SIDEBAR (INTEGRANTES) --- */
        .sidebar {
            width: 300px;
            background: rgba(0, 20, 0, 0.6); /* Fundo semi-transparente */
            backdrop-filter: blur(10px); /* Efeito de vidro fosco */
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            height: fit-content;
            align-self: flex-start; /* Alinha no topo ou center conforme preferir */
            margin-top: 20px;
            
            /* Anima√ß√£o de entrada */
            transform: translateX(20px);
            opacity: 0.9;
            transition: 0.3s;
        }

        .sidebar:hover {
            border-color: #ffff00; /* Borda amarela ao passar o mouse */
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.2);
        }

        .sidebar h2 {
            font-family: 'Orbitron', sans-serif;
            color: #00ff00;
            font-size: 1.2rem;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 10px;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar li {
            margin-bottom: 12px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            font-family: 'Orbitron', sans-serif;
        }

        /* √çcone alien√≠gena antes do nome */
        .sidebar li::before {
            content: 'üëΩ'; 
            margin-right: 10px;
            filter: hue-rotate(90deg); /* Deixa o alien mais esverdeado */
        }

        /* --- ANIMA√á√ÉO GLITCH NO T√çTULO --- */
        @keyframes glitch {
            0% { text-shadow: 2px 2px 0px #ff00de, -2px -2px 0px #00ff00; }
            25% { text-shadow: -2px 2px 0px #ff00de, 2px -2px 0px #00ff00; }
            50% { text-shadow: 2px -2px 0px #ff00de, -2px 2px 0px #00ff00; }
            75% { text-shadow: -2px -2px 0px #ff00de, 2px 2px 0px #00ff00; }
            100% { text-shadow: 2px 2px 0px #ff00de, -2px -2px 0px #00ff00; }
        }

        /* --- RESPONSIVIDADE --- */
        @media (max-width: 900px) {
            .content-wrapper {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                max-width: 600px;
                display: flex;
                flex-direction: row;
                gap: 20px;
                justify-content: center;
                align-items: center;
            }
            .sidebar h2 {
                border-bottom: none;
                border-right: 2px solid #00ff00;
                padding-right: 10px;
                margin-bottom: 0;
            }
        }
    </style>

    <script id="vertex-shader" type="notjs">
        attribute vec4 position;
        attribute vec3 normal;
        attribute vec2 texCoord;

        uniform mat4 transf;
        uniform mat4 view;
        uniform mat4 projection;

        varying vec3 v_normal;
        varying vec3 v_worldPosition;
        varying vec2 v_texCoord;

        void main() {
            v_texCoord = texCoord;
            vec4 worldPos = transf * position;
            v_worldPosition = worldPos.xyz;
            v_normal = mat3(transf) * normal;
            
            gl_Position = projection * view * worldPos;
        }
    </script>

    <script id="frag-shader" type="notjs">
        precision mediump float;
        uniform sampler2D tex;
        varying vec3 v_normal;
        varying vec3 v_worldPosition;
        varying vec2 v_texCoord;

        uniform vec3 u_lightPosStatic;
        uniform vec3 u_lightPosDynamic;
        uniform vec3 u_viewPosition;

        uniform bool u_useTexture;  // Vem do JS (true/false)
        uniform vec4 u_color;       // Vem do JS (R, G, B, A)

        void main() {
            // Normaliza√ß√£o dos vetores
            float squares_vector_sum = sqrt(v_normal.x * v_normal.x + v_normal.y * v_normal.y + v_normal.z * v_normal.z);
            vec3 N = v_normal / squares_vector_sum;

            vec3 viewDir = u_viewPosition - v_worldPosition;
            squares_vector_sum = sqrt(viewDir.x * viewDir.x + viewDir.y * viewDir.y + viewDir.z * viewDir.z);
            vec3 V = viewDir / squares_vector_sum;

            // Luz est√°tica
            vec3 lightDir = u_lightPosStatic - v_worldPosition;
            squares_vector_sum = sqrt(lightDir.x * lightDir.x + lightDir.y * lightDir.y + lightDir.z * lightDir.z);
            vec3 Lstatic = lightDir / squares_vector_sum;

            // Luz din√¢mica
            lightDir = u_lightPosDynamic - v_worldPosition;
            squares_vector_sum = sqrt(lightDir.x * lightDir.x + lightDir.y * lightDir.y + lightDir.z * lightDir.z);
            vec3 Ldynamic = lightDir / squares_vector_sum;

            // C√°lculo de difusa (Lambert)
            float dotNL = (N.x * Lstatic.x) + (N.y * Lstatic.y) + (N.z * Lstatic.z);
            float diffstatic = max(dotNL, 0.0);

            dotNL = (N.x * Ldynamic.x) + (N.y * Ldynamic.y) + (N.z * Ldynamic.z);
            float diffdynamic = max(dotNL, 0.0);

            // Phong Reflection Model manual
            // Luz Est√°tica
            vec3 I = -Lstatic; 
            float dotNI = (N.x * I.x) + (N.y * I.y) + (N.z * I.z);
            // Reflect: I - 2.0 * dot(N, I) * N
            vec3 Rstatic = I - 2.0 * dotNI * N;

            float dotRV = (Rstatic.x * V.x) + (Rstatic.y * V.y) + (Rstatic.z * V.z);
            float specstatic = pow(max(dotRV, 0.0), 50.0);

            // Luz Din√¢mica
            I = -Ldynamic;
            dotNI = (N.x * I.x) + (N.y * I.y) + (N.z * I.z);
            vec3 Rdynamic = I - 2.0 * dotNI * N;

            dotRV = (Rdynamic.x * V.x) + (Rdynamic.y * V.y) + (Rdynamic.z * V.z);
            float specdynamic = pow(max(dotRV, 0.0), 50.0);

            // -In√≠cio do bloqueio de luz(gating)
            
            float sunMask = 1.0; 

            // Defini√ß√µes do seu cen√°rio (hardcoded conforme seu JS)
            float wallWidth = 20.0;     // Onde come√ßa a parede principal
            float wallHeight = 30.0;    // Altura m√°xima da parede
            float nicheDepth = 8.0;     // Profundidade do cubo do nicho
            float maxExtent = wallWidth + nicheDepth; // 28.0


            bool sunIsOutside = abs(u_lightPosDynamic.x) > wallWidth;

            // (Se estiver muito alto, > 30, ele ilumina o ch√£o por cima)
            bool sunIsLow = u_lightPosDynamic.y < wallHeight;

            // Consideramos interno qualquer coisa dentro da extens√£o total da geometria (X < 28)
            // e abaixo da altura da parede.
            bool pixelIsInterior = abs(v_worldPosition.x) < (maxExtent + 0.5) && v_worldPosition.y < wallHeight;


            // Se o sol est√° fora e baixo, e o pixel √© interno, temos uma parede entre eles.
            // O "cubo" do nicho √© s√≥lido, ent√£o ele tamb√©m bloqueia a luz vinda de tr√°s dele.
            if (sunIsOutside && sunIsLow && pixelIsInterior) {
                sunMask = 0.0;
            }

            // Aplica a m√°scara
            diffdynamic *= sunMask;
            specdynamic *= sunMask;

            // Fim do bloqueio de luz

            vec4 baseColor;

            if (u_useTexture) {
                // Se o JS disse que tem textura, l√™ a imagem
                baseColor = texture2D(tex, v_texCoord);
            } else {
                // Se n√£o, usa a cor s√≥lida (verde, vermelho, etc)
                baseColor = u_color;
            }

            float ambient = 0.2;
            
            // Combina√ß√£o final
            float lightFactor = (ambient + (diffstatic + diffdynamic) + (specstatic + specdynamic) * 0.5);

            gl_FragColor = vec4(lightFactor * baseColor.rgb, baseColor.a);
        }
    </script>

    <script type="module" src="main.js"></script>
</head>

<body>
    <div class="container">
        <header>
            <h1>Area 51 Brasil</h1>
        </header>

        <div class="content-wrapper">
            <div class="canvas-container">
                <canvas id="glcanvas1" width="1000" height="600"></canvas>
            </div>

            <aside class="sidebar">
                <h2>Desenvolvedores:</h2>
                <ul>
                    <li>Pedro Henrique Luna Lessa</li>
                    <li>Ant√¥nio √çcaro Morais Pinto</li>
                    <li>Lucas Levi Santos de Medeiros</li>
                </ul>
            </aside>
        </div>
    </div>
</body>
</html>